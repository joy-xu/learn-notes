插入模式:
    字符位置插入:
        i : 在光标之前插入(Insert 模式，按 ESC(或者<C-[>) 回到 Normal 模式)
        a : 在光标后插入
	行位置插入：
	    A : 在一行的结尾处追加
	    I : 在一行的开头处插入
	    o(小写字母o) : 在当前行后插入一个新行
	    O(大写字母O) : 在当前行前插入一个新行
	    cw : 替换从光标所在位置后到一个单词结尾的字符
        J : 合并两行(当前行和下一行)
	技巧:
	    10I*<Esc>先输入10, 然后输入I, 接着输入*号, 最后按<Esc>, 这样就可以在一行开头输入十个*
            5o###<Esc>先输入5, 然后输入o, 接着输入###, 最后按<Esc>, 这样就可以在下列5行中每一行开头插入###

普通模式:
   『操作符』+『动作命令』= 操作, 例如 d{motion} daw dap dl等, c{motion} caw cw, y{motion} yaw yw d/ge(从当前位置删除到/ge查找到的位置)等
    Vim中的操作符:
	c(修改)、d(删除)、y(复制到寄存器)、g~(反转大小写)、gu(转换为小写)、gU(转换为大写)、>(增加缩进)、<(减小缩进)、=(自动缩进)、!(使用外部程序过滤{motion}所跨越的行)
    Vim的语法只有一条额外规则, 即当一个『操作符』命令被连续调用两次时, 它会作用于当前行, 例如 dd、>>、gUgU(缩写gUU)等

操作符待决模式(Operator Pending Mode):
    持续时间很短, 可以理解为只接受『动作命令』的状态. 例如dw, 在d和w之间的状态就是操作符待决模式, 可以使用Esc退出该模式到普通模式。只有操作符才可以激活操作符待决模式

插入模式下:
	删除:
		<C-h> 删除光标前一个字符(同退格键)
		<C-w> 删除从光标开始往前到单词开头
		<C-u> 删至行首
	粘贴寄存器中的文本<C-r>{register}
		<C-r>0 : 复制寄存器中的文本粘贴到光标所在位置
		<C-r>" : 复制无名寄存器中的文本到光标所在位置

	用 = 符号指明使用『表达式寄存器』(它可以用来执行一段Vim脚本，并返回其结果):
	    <C-r>= : 可以访问表达式寄存器, 这条命令会在屏幕的下方显示一个提示符, 我们可以在其后输入要执行的表达式.
		      输入表达式后敲一下<CR>, Vim 就会把执行的结果插入到文档的当前位置了(<C-r>=6*35<CR>)
	
	使用字符编码插入非”常用”字符(把光标移到任意字符上面并输入ga命令, 屏幕下方就会分别以十进制和十六进制的形式显示出其字符编码):
            <C-v>{123} : 以十进制字符编码插入字符(<C-v>123)
            <C-v>u{1234} : 以十六进制字符编码插入字符(<C-v>u00bf)
            <C-v>{nondigit} : 按原义插入非数字字符(<C-v>abc)
            <C-k>{char1}{char2} : 插入以二合字母{char1}{char2}表示的字符(<C-k>12:输入1/2， <C-k> <<：输入书名号«)
	
插入-普通模式: 插入-普通模式是普通模式的一个特例, 它能让我们执行一次普遍模式命令, 执行完后, 马上就又返回到插入模式
	要从插入模式切换到插入-普通模式, 可以按<C-o>, 例如<C-o>zz

替换模式: R命令可以由普通模式进入替换模式, 之后输入的每个字符将替换掉原来的字符(按字符替换); r: 单次版本的替换模式(覆盖一个字符后立马回到普通模式)

虚拟替换模式: gR命令可以由普通模式进入虚拟替换模式, 之后输入的每个字符将替换掉原来的字符(按屏幕实际显示的宽度进行替换, 比如tab占据屏幕8列宽, 会将其当做8个空格进行处理); gr: 单次版本的替换模式(覆盖一个字符后立马回到普通模式)

可视模式:
    普通模式下,
	v激活面向字符的可视模式(再次按v回到普通模式); V激活面向行的可视模式(再次按V回到普通模式); <C-v> 激活面向列块的可视模式(再次按<C-v>回到普通模式); gv重选上次的高亮选区; 可视模式之间可以直接按v、V、<C-v>进行切换
	o :　切换高亮选区的活动端
    u(U): 小写(大写)选中的文本

选择模式: <C-g>可以在可视模式及选择模式间切换, 切换后不同的是屏幕下方的提示信息会在(-- VISUAL --)及(--SELECT—)间转换, 如果在选择模式输入字符的话, 会替换所选内容并进入插入模式; 可视模式可以输入c键来修改内容

命令行模式:
    Ex命令影响范围广且距离远, Vim为几乎所有功能都提供了相应的Ex命令
	
	:[range]delete [x] : 删除指定范围[range]内的行(到寄存器x中)(delete <==> d)
	:[range]yank [x] : 复制指定范围的行(到寄存器x中)(yank <==> y)
	:[line]put [x] : 在指定行后粘贴寄存器x的内容
	:[range]print : 打印指定范围[range]内的行(print <==> p)
	:[range]copy {address} : 将指定范围内行拷贝到{address}所指定行之下(copy <==> co <==> t) copy To
	:[range]move {address} : 将指定范围内的行移动到{address}所指定行下(move <==> m)
	:[range]join : 连接指定范围内的行
	:[range]normal {commands} : 对指定范围内的每一行执行普通命令{commands}, 在执行{commands}前, vim会先把光标移动到该行的起始处。:%normal i// : 把文件所有内容注释掉。可以结合使用:normal .完成重复性工作
	:[range]substitute/{pattern}/{string}/[flags] : 对指定范围内出现{pattern}的地方替换为{string} (substitute <==> s)
	:[range]global/{pattern}/[cmd] : 对指定范围内匹配{pattern}的所有行(默认整个文件%), 在其上执行Ex命令{cmd}
 
	指定地址的方式, 可以使用行号、位置标记或者查找模式来指定: 
		1. 使用行号作为地址, :6t.(将第6行复制到当前行下方); :1(跳转到第1行位置); :3p(打印第三行)
		2. 用地址指定一个范围, ${start}, ${end}. 例如 5, 6print(打印5到6行, 打印完后, 光标会停留在第6行)
		3. 用高亮区指定范围, 先选中, 再输入:会自动进入命令模式
		4. 用模式指定范围, /<html>/,/<\/html>/p(打印从<html>到</html>之间内容)
		5. 使用偏移地址({address}+n)修正, /<html>/+1,/<\/html>-2/p
	地址以及范围符号总结:
	1	文件第一行
	$	文件最后一行
	0	虚拟行，位于文件第一行上方
	.	光标所在行
	‘m	包含位置标记m的行
	‘<	高亮选取起始行
	‘>	高亮选区结束行
	%	整个文件(:1,$缩写)
	
	:%normal A; : 在文件每行的结尾添加一个分号; 上一步操作了A;操作之后, 可以使用:normal .完成相同的A;重复操作
	
	重复执行上次的Ex命令: @:即可。&可以特指重复执行上次的:substitute命令
	<C-d>命令让vim显示可用的补全列表, <Tab>键自动补全命令(默认补全列表中第一个, 然后正向遍历, <S-Tab>反向遍历)
	<C-r><C-w>复制光标下的单词并把它插入到命令行中(<C-r><C-a>插入光标下字串)。:%s/<C-r><C-w>/ok/gc : 将当前单词替换为ok
	
	回溯历史命令: 
		按:键切换到命令行模式, <Up>键回溯执行过的历史命令, <Down>键相反方向回溯(set history=200设置记录的历史命令数量)
		<C-p>、<C-n>也可以正向/反向遍历命令历史, 但是不会有<Up>/<Down>对命令进行过滤(根据已经输入的前缀过滤). 以下自定义映射项可以做到这个
			cnoremap <C-p> <Up>
                	cnoremap <C-n> <Down>
	
	命令行窗口:
		q/ : 打开"查找命令历史"的命令行窗口
		q: : 打开"Ex命令历史"的命令行窗口(可以使用k/j进行上/下移动, 也可以/{pattern}进行搜索), 在选中项后<CR>自动执行, 或者:q命令退出. 该窗口拥有完整的区分模式的编辑功能来修改或者组合命令.
		
		<C-f> : 从命令行模式切换到命令行窗口

	:!{cmd} : 在shell中执行{cmd}(:!ls -la); 
	:shell : 启动一个shell，输入exit返回vim
	:read !{cmd} : 在shell中执行{cmd}，并把标准输出插入到光标下
	:[range]write !{cmd} : 在shell中执行{cmd}，以[range]作为其标准输入
	:[range]!{filter} : 使用外部{filter}过滤指定的[range](:2,$!sort -t’,’ -k2) 
	
	:w[rite] : 把缓冲区内容写入磁盘
	:e[dit]! : 把磁盘文件内容读入缓冲区(即回滚所做修改)
	:qa[all]! : 关闭所有窗口，摒弃修改而无需警告
	:wa[all]

文件:
	缓冲区: 
		:ls : 列出所有被加载到内存中的缓冲区列表(. 缓冲区编号Vim自动分配)
			%指明哪个缓冲区在当前窗口可见
			#代表轮换文件(<C-^>可以在当前文件和轮换文件之间快速切换)
			+代表这个缓冲区被修改过了
			a代表活动缓冲区(active)
			h代表隐藏缓冲区(hidden)
		:bprev/:bnext : 切换到缓冲区列表中的下/上一个缓冲区(:bp/:bn)
		:bfirst/blast : 跳到列表的开头/结尾(:bf/:bl)
		:buffer {n} : 跳转到编号为n的缓冲区(:b 1)
		:buffer {bufName} : {bufname}只需􏳌􏵚包含􏰬文件路径中唯一标识此缓冲区的字符即可(:b a)
		:bdelete n1 n2 n3 : 删除n1 n2 n3缓冲区(:bd 1 2 3); 或者 :n,m bdelete(:5,10bd)
		:bufdo {cmd} : 对缓冲区中的文件执行{cmd}命令
	参数列表:
		:args {arglist} : {arglist}可以包括文件名􏰬􏶫、通配符甚至􏸺是一条􏴓shell命令的输出结果
			:args index.html app.js
			:args *.*	:args **/*.js	:args **/*.*
			:args `cat .chapters`
		:next/:prev : 遍历参数列表中的文件
		:argdo {cmd} : 对参数列表中的文件执行{cmd}命令
	分割窗口:
		<C-w>s : 水平切分当前窗口, 新窗口仍然显示当前缓冲区
		<C-w>v : 垂直切分当前窗口, 新窗口仍然显示当前缓冲区
		:sp[lit] {file} : 水平切分当前窗口, 并在新窗口中载入{file}. 等价于执行<C-w>s, 再执行:edit {file}
		:vsp[lit] {file}: 垂直切分当前窗口, 并在新窗口中载入{file}. 等价于执行<C-w>v, 再执行:edit {file}
		
		窗口切换
			<C-w>w : 在窗口间循环切换. 等价于<C-w><C-w>
			<C-w>h/j/k/l : 切换到左/下/上/右的窗口
		关闭窗口
			Ex命令	  	普通模式命令	用途
			:clo[se]	<C-w>c 		关闭活动窗口
			:on[ly]		<C-w>o		只保留活动窗口, 关闭其他所有窗口
		改变窗口大小
			<C-w>= : 使所有窗口等宽、等高
			<C-w>_ : 最大化活动窗口的高度
			<C-w>| : 最大化活动窗口的宽度
			{n}<C-w>_ : 把活动窗口的高度设为[n]行
			{n}<C-w>| : 把活动窗口的宽度设为[n]列

	:e[dit] {file} : 通过绝对/相对路径打开文件{file}(Tab 自动补全)
		1. %代表活动缓冲区的完整文件路径(:edit % <==> :edit app/controller/app.js). 在命令行中, %具有特殊含义, 它会展开成当前文件的完整路径
		2. %:h会去除文件名但会保留路径中的其他部分(:edit %:h <==> :edit app/controller/)
			加上此配置到vimrc中(cnoremap <expr> %% getcmdtype( ) == ':' ? expand('%:h').'/' : '%%'), %%就代表%:h

		3. 如果编辑的是一个不存在的目录/文件(<C-g>会提示[New File]状态), 如果是文件不存在可以直接:w保存, 如果目录不存在则无法保存. 可以借助:!mkdir -p %:h创建目录后再执行:w保存
		

	:find {file} : 通过文件名打开文件, 但必须提前设置好path选项的值(set path+=app/**)
	
	Vim原生的文件管理器netrw(across NETwork Read and Write files), 确保vimrc中配置有set nocompatible以及filetype plugin on配置
		vim {directory} 即可进入netrw管理的
		:e[dit] . : 打开文件管理器, 并显示当前工作目录. 可以通过<C-^>切换文件管理器和编辑文件的视图
		:E[xplore] : 打开文件管理器, 并显示活动缓冲区所在目录

	:w !sudo tee % > dev/null : 以系统管理员root用户保存文件

	:pwd : 打印工作目录(print working directory)
	:quit : 关闭编辑会话(:q)
	:w[rite] : 把缓冲区内容写入磁盘
	:e[dit]! : 把磁盘文件内容读入缓冲区(即回滚所做修改)
	:qa[all]! : 关闭所有窗口，摒弃修改而无需警告
	:wa[all]

寄存器:
	"{register} : 引用{register}寄存器(:reg a查看a寄存器内容), "ayiw : 当前单词复制到寄存器a中; "bdd : 当前整行文本剪切至b寄存器; "ap : 粘贴来自a寄存器的单词; "bp : 粘贴寄存器b的整行文本
	"" : 无名寄存器, Vim缺省使用无名寄存器(""p <==> p), x、s、d/c/y{motion}默认都放入无名寄存器中
	"0 : 复制专用寄存器, 只有y{motion}才会被赋值(yaw), 使用复制专用寄存器粘贴复制的内容("0p)
	"{a-zA-Z} : 有名寄存器, 显式指定寄存器(小写字母引用会覆盖寄存器内容, 大写字母append追加), "ayiw "ap "byiw "bp
	"_ : 黑洞寄存器, 有去无回的地方, "_d{motion} : 删除该文本且不保存任何副本
	"+ : 加号寄存器<==>系统剪贴板, 主要与外部程序交互. "+p : 将系统剪贴板内容复制到光标位置(插入模式下: <C-r>+); "+yiw : 复制当前单词到系统剪贴板中
	"= : 表达式寄存器
	只读寄存器, Vim提供了几组可被隐式赋值的寄存器:
		"% : 当前文件名
		"# : 轮换文件名
		". : 上次插入的文本
		": : 上次执行的Ex命令
		"/ : 上次查找的模式
	
	
光标移动: 
	hjkl: 分别对应使用光标键 (←↓↑→), j和k根据实际行向下及向上移动, gj和gk根据屏幕行向下/上移动
    
	整行移动, j/k/0/$等默认都基于实际行移动, 加上g前缀的话会基于屏幕行移动
		0(数字0) : 到实际行行首; g0 : 到屏幕行行首
		^(Shift+6) : 到实际行第一个不是blank字符的位置(所谓blank字符就是空格, tab, 换行, 回车等); g^ : 到屏幕行
		$(Shift+4) : 到实际行行尾; g$ : 到屏幕行行尾
    		g_ : 到本行最后一个不是blank字符的位置
		+ : 移动到下一行开头
		- : 移动到上一行开头

	f(F){char}: 行内向后(前)查找到指定字符, 并跳转到字符所处的位置(3fa即移动到从当前光标起第三个a字符的位置; {char}最好选择出现频率比较低的字母作为目标字符)。 :set hls[!]命令设置是/否搜索单词高亮
	    当搜索指定字符时, 可以使用;(分号)跳转到下一处--不管是t搜索还是f搜索; ,(逗号)可以用来反向跳转到上一处
	t(T){char} : 正向(反向)查找到指定字符, 并跳转到这个字符的前(后)一个字符上(ctg: 修改到下一个”g”之间的内容) search till the specified character
	
    
	/pattern : 从当前位置正向搜索 pattern 的字符串(如果搜索出多个匹配，可按n键到下一个, N键到上一个; <Up>/<Down>回溯历史查找的记录)
	?pattern : 从当前位置逆向搜索 pattern 的字符串(如果搜索出多个匹配，可按n键到下一个, N键到上一个; <Up>/<Down>回溯历史查找的记录), 如果省略查找域(/或者?)将会重用上一次的查找模

    	{n}G : 到第 n 行(注意命令中的G是大写的, 另一般使用 :{n} 到第n行, 如 :137 到第137行)
    	{n}| : 移动到当前行的第n列
    	gg: 到第一行
    	G: 到最后一行

	按单词移动:
		如果单词是由默认方式, 那么就用小写的e、w和b。默认上来说, 一个单词由字母、数字和下划线组成(程序变量), 如果你认为单词是由blank字符分隔符, 那么你需要使用大写的E、W和B(程序语句)
		w : 正向移动到下一个单词的开头(for-word, 3w: 移动3个单词)
		b : 反向移动到当前单词/上一单词的开头(back-word)
		e : 正向移动到当前单词/下一单词的结尾
		ge : 反向移动到上一单词的结尾
		% : 匹配括号移动，包括 (, {, [。(你需要把光标先移到括号上)
		* 和 #:  匹配光标当前所在的单词, 移动光标到下一个(或上一个)匹配单词(*是下一个, #是上一个; 查找一次后可以使用n/N进行匹配词之间的移动)
    	按标记移动:
		m{a-zA-Z} : 标记当前光标所在位置(小写位置标记在每个缓冲区局部可见, 大写位置标记全局可见)
		`{letter} : 跳转到标记{letter}上(`a/`A); Vim自动会帮我们设置一些位置标记:
			`` : 当前文件中上次跳转之前的位置
			`. : 上次修改的地方
			`^ : 上次退出插入模式时光标所在的位置(`^ <-> gi : gi命令会用`^标记恢复光标位置并切换到插入模式)
			`[ : 上次修改/复制的起始位置
			`] : 上次修改/复制的结束位置
			`< : 上次高亮选取的起始位置
			`> : 上次高亮选取的结束位置
    	滚屏:
        	<C-f> : 往前滚动一整屏(Forwards)
       		<C-b> : 往后滚动一整屏(Backwards)

		<C-d> : 往前滚动半屏(Downwards)
		<C-u> : 往后滚动半屏(Upwards)

		<C-e> : 往前滚动一行(Extra, 额外的行)
		<C-y> : 往后滚动一行
	
	使用z调整光标:
         z<Enter> : 将光标所在行移动到屏幕顶端(500z<Enter>可以将第500行移动到屏幕顶端)
         z.(或者zz) : 将光标所在行移动到屏幕中间(500z.可以将第500行移动到屏幕中间)
         z- : 将光标所在行移动到屏幕底端(500z-可以将第500行移动到屏幕底端)
    
	在屏幕中移动:
		H　: 移动到屏幕顶端的行(High)
		M　: 移动到屏幕中央的行(Middle)
		L　: 移动到屏幕底端的行(Low)
		{n}H : 移动到屏幕顶端往下的第n行
		{n}L : 移动到屏幕顶端往上的第n行
	
	文件间跳转:
		跳转列表:
			大范围的动作命令可能会被当做跳转, 如:edit改变窗口活动文件、[n]G行跳转、面向句子/段落的跳转、H/M/L跳转等; 小范围的动作命令只能算移动, 如jk行移动、面向字符/单词的移动等
			:jumps : 查看跳转列表. <C-o>/<C-i>用于在跳转列表中遍历(<C-o>相当于后退, <C-i>相当于前进)
		改变列表:
			:changes : 查看改变列表. g; g, 用来在改变列表中反向/正向遍历改变列表(第一次g; 与 `. 效果相同)
		gf : 跳转到光标下的文件名
		<C-]> : 跳转到光标下关键字的定义之处
		
删除:
    
	字符删除:
        x(小写x) : 删除光标所在处字符
        X(大写X) : 删除光标所在前字符
        J : 将上下两行合并(删除两行之间的换行符)
		
	单词删除: d{motion} (d <->delete)
		dl : 删除一个字符
		dw : 删除到下一个单词开头(d2w :　删除两个, 2w是删除操作的motion; 2dw : 重复两次dw操作)
		de : 删除到本单词末尾
		dE : 删除到本单词末尾包括标点在内
		db : 删除到前一个单词
		dB : 删除到前一个单词包括标点在内
		dt. : 删除当前位置到下一个句号之间的所有内容
		D : 删除当前光标位置到本行末的所有内容(不会进入插入模式)
		daw : 删除光标位置的单词(delete a word)
		dap : 删除一个段落(delete a paragraph)
		
	行删除:
		dd : 删除一整行
		d$ : 删除光标位置到本行结尾
		d0 : 删除光标位置到本行开头

替换:
    字符替换:
	r : 单个字符替换
	R : 连续替换
	~ : 更改大小写(4～更改连续4个字符的大小写)
	gu{motion} : Make {motion} text lowerCase(guap : 把整段文字转换为小写形式)
	guu(或gugu) : 当前行小写
        guaw : 当前单词小写
	gU{motion} : Make {motion} text upperCase(gUaw : 把当前单词转换成大写形式)
	gUU(或gUgU) : 当前行大写
        gUap : 当前段落大写
	g~{motion} : Switch case of {motion} text
	g~~(或g~g~) : 当前行大小写转换

    单词修改c{motion}: (c <-> change)
	cw : 从光标处修改到单词结尾(此时2cw 或者 c2w都可以使用, 功能一样), 并进入插入模式
	cb : 从光标处修改到单词开头, 并进入插入模式

    行修改:
	c{motion}：修改文本{一个单词, 一句或者一个段落}
        c$ :　从光标修改到本行末尾
        C : 能同上(修改当前所在行) <==> c$
        c0 : 从光标修改到本行开头
	cc : 删除整行从头修改
        S : 功能同上(替换整行) <==> ^C <==> cc
        s : 删除光标所在位置的字符, 然后插入(替换当前字符) <==> cl
	ct? : 修改问号前的这条问句内容

        :s : 命令模式下, 
		:s/old/new, 将光标所在行的第一个old替换为new
		:s/old/new/g, 替换全行的匹配串
		:%s/old/new/g替换整个文件中的old为new
		:#,#s/old/new/g, 替换两行中间的每个匹配串
        在一行內替換頭一個字符串 old 為新的字符串 new, 請輸入  :s/old/new
        在一行內替換所有的字符串 old 為新的字符串 new, 請輸入  :s/old/new/g
        在兩行內替換所有的字符串 old 為新的字符串 new, 請輸入  :#,#s/old/new/g
        在文件內替換所有的字符串 old 為新的字符串 new, 請輸入  :%s/old/new/g
        進行全文替換時詢問用戶確認每個替換需添加 c 選項, 請輸入 :%s/old/new/gc
		
拷贝粘贴:
    粘贴:
        p(小写p) : 在当前位置之后粘贴(p <-> put); 粘贴面向行的区域时(yy/dd/yap等), p执行后光标会位于粘贴后文本开头, gp执行后光标位于粘贴文本结尾
        P(大写P) : 在当前位置之前粘贴
    复制:
	单词和字符复制y{motion}: (y <-> yank)
		ynl : 向右复制n个字符
		ynh : 向左赋值n个字符
		ynw : 向前复制ｎ个单词
		ynb : 向后复制n个单词
		ye : 从当前位置拷贝到本单词的最后一个字符
		yt, : 从当前位置复制到下一个逗号

	行复制:
	    yy : 拷贝当前行，相当于 ddP( 4yy也就是复制4行)
	    y$ : 复制到行末
	    y0 : 复制到行首
	    yH : 从当前行复制到屏幕顶端
	    yL : 从当前行复制到屏幕低端

Undo/Redo:
    u : 撤消上次命令(undo, 如果在插入模式中使用了<Up>、<Down>、<Left>、<Right>这些光标键, 将会产生个新的撤销块, 这也会对.命令的操作产生影响)
    U : 恢复整行(撤销在一行中所做的改动，恢复本行内容)
    <C-r> : 恢复整行(redo, 撤销掉以前的”撤销命令”)
    . : 重复
    :e! : 全文恢复(只要你还没使用过w、wp或x保存)
	
打开/保存/退出/改变文件:
        :e <path/to/file> : 打开一个文件
	:w : 存盘(:w fileName, 保存到fileName文件)
	:saveas <path/to/file> : 另存为 <path/to/file>
	:q! : 退出不保存 
	:qa! : 强行退出所有的正在编辑的文件，就算别的文件有更改
	:x, ZZ 或 :wq : 保存并退出(:x 表示仅在需要时保存, ZZ不需要输入冒号并回车)
	
重复:
    .(小数点) : (小数点)可以重复上一次的修改
	从进入插入模式的那一刻起(例如, 输入 i), 直到返回普通模式时为止(输入<Esc>), Vim 会记录每一个按键操作。做出这样一个修改后再用 . 命令的话, 它将会重新执行所有这些按键操作
    N<command> : 重复某个命令N次(2dd → 删除2行, 3p → 粘贴文本3次, 100ihello [ESC] -> 重复插入100次hello)


:help <command> : 显示相关命令的帮助
>G : 增加从当前行到文档末尾处的缩进层级
K : 查看处于光标之下的那个单词的手册页

<C-a> : 对数字执行加操作(把当前光标之上或之后的数值加上[count])(180<C-a> : 在当前行正向查找一个数字, 如果找到了, 它就径直跳到那里, 并加180)
<C-x> : 对数字执行减操作(把当前光标之上或之后的数值减去[count])(Vim 默认把以0开头的数字解释为八进制值, 而不是十进制, 可以使用 set nrformats= 将Vim把所有数字都当成十进制(可以加入到vimrc文件中) )

<C-g> : 用于顯示當前光標所在位置和文件狀態信息

>> : 当前行增加缩进
<< : 当前行减小缩进
== : 当前行自动缩进


** 要保存文件的部分內容, 請輸入 :#,# w FILENAME **（#代表行号）
** 要向當前文件中插入另外的文件的內容, 請輸入 :r FILENAME **


<C-o> : 反向遍历"跳转"列表, 回到您之前"跳转"的位置
<C-i> : <C-o>的反向

it: 作为{motion}, 表示inside the tag, 比如vit表示选中标签内的文本<h1>Hello World</h1>将选中Hello World, gUit表示将标签内文本大写化

文本对象: 基于结构定义的文本区域, 大致可以分为『分隔符文本对象』和『范围文本对象』;(a <-> around/all, i <-> inside)
	
	『分隔符文本对象』:
	a) : 一对圆括号(parentheses)，内部文本+圆括号 around
	i) : 圆括号内部,只包含括号内部文本 inside
	a} : 一对花括号{braces}
	i} : 花括号内部
	a] (i]) : 方括号 ; a> (i>) : 尖括号 ; a’ (i’) : 单引号 ; a” (i”) : 双引号 ; a`(i`) : 反引号
	at : 一对XML标签(<xml>tags</xml>)
	it : XML标签内部(inside the tag)
	
	『范围文本对象』,一般来说, d{motion}命令和aw/as/ap配合使用比较好, 而c{motion}命令和iw/is/ip配合使用比较好
	iw : 当前单词
	aw : 当前单词及一个空格
	iW : 当前字串
	aW : 当前字串及一个空格
	is : 当前句子
	as : 当前句子及一个空格
	ip : 当前段落
	ap : 当前段落及一个空格

    假设有一个字符串 (map (+) ("foo")), 而光标键在第一个 o 的位置
	vi" 会选择 foo
	va" 会选择 "foo"
	vi) 会选择 "foo"
	va) 会选择("foo")
	v2i) 会选择 map (+) ("foo")
	v2a) 会选择 (map (+) ("foo"))
	

